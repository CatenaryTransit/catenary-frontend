/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: gtfs-realtime.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from 'google-protobuf';
export namespace transit_realtime {
	export class FeedMessage extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						header: FeedHeader;
						entity: FeedEntity[];
				  }
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[2],
				this.#one_of_decls
			);
			if (!Array.isArray(data) && typeof data == 'object') {
				this.header = data.header;
				this.entity = data.entity;
			}
		}
		get header() {
			return pb_1.Message.getWrapperField(this, FeedHeader, 1) as FeedHeader;
		}
		set header(value: FeedHeader) {
			pb_1.Message.setWrapperField(this, 1, value);
		}
		get has_header() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get entity() {
			return pb_1.Message.getRepeatedWrapperField(this, FeedEntity, 2) as FeedEntity[];
		}
		set entity(value: FeedEntity[]) {
			pb_1.Message.setRepeatedWrapperField(this, 2, value);
		}
		static fromObject(data: {
			header?: ReturnType<typeof FeedHeader.prototype.toObject>;
			entity?: ReturnType<typeof FeedEntity.prototype.toObject>[];
		}): FeedMessage {
			const message = new FeedMessage({
				header: FeedHeader.fromObject(data.header),
				entity: data.entity.map((item) => FeedEntity.fromObject(item))
			});
			return message;
		}
		toObject() {
			const data: {
				header?: ReturnType<typeof FeedHeader.prototype.toObject>;
				entity?: ReturnType<typeof FeedEntity.prototype.toObject>[];
			} = {};
			if (this.header != null) {
				data.header = this.header.toObject();
			}
			if (this.entity != null) {
				data.entity = this.entity.map((item: FeedEntity) => item.toObject());
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_header) writer.writeMessage(1, this.header, () => this.header.serialize(writer));
			if (this.entity.length)
				writer.writeRepeatedMessage(2, this.entity, (item: FeedEntity) => item.serialize(writer));
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FeedMessage {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new FeedMessage();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						reader.readMessage(
							message.header,
							() => (message.header = FeedHeader.deserialize(reader))
						);
						break;
					case 2:
						reader.readMessage(message.entity, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								2,
								FeedEntity.deserialize(reader),
								FeedEntity
							)
						);
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): FeedMessage {
			return FeedMessage.deserialize(bytes);
		}
	}
	export class FeedHeader extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						gtfs_realtime_version: string;
						incrementality?: FeedHeader.Incrementality;
						timestamp?: number;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				this.gtfs_realtime_version = data.gtfs_realtime_version;
				if ('incrementality' in data && data.incrementality != undefined) {
					this.incrementality = data.incrementality;
				}
				if ('timestamp' in data && data.timestamp != undefined) {
					this.timestamp = data.timestamp;
				}
			}
		}
		get gtfs_realtime_version() {
			return pb_1.Message.getField(this, 1) as string;
		}
		set gtfs_realtime_version(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get has_gtfs_realtime_version() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get incrementality() {
			return pb_1.Message.getFieldWithDefault(
				this,
				2,
				FeedHeader.Incrementality.FULL_DATASET
			) as FeedHeader.Incrementality;
		}
		set incrementality(value: FeedHeader.Incrementality) {
			pb_1.Message.setField(this, 2, value);
		}
		get has_incrementality() {
			return pb_1.Message.getField(this, 2) != null;
		}
		get timestamp() {
			return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
		}
		set timestamp(value: number) {
			pb_1.Message.setField(this, 3, value);
		}
		get has_timestamp() {
			return pb_1.Message.getField(this, 3) != null;
		}
		static fromObject(data: {
			gtfs_realtime_version?: string;
			incrementality?: FeedHeader.Incrementality;
			timestamp?: number;
		}): FeedHeader {
			const message = new FeedHeader({
				gtfs_realtime_version: data.gtfs_realtime_version
			});
			if (data.incrementality != null) {
				message.incrementality = data.incrementality;
			}
			if (data.timestamp != null) {
				message.timestamp = data.timestamp;
			}
			return message;
		}
		toObject() {
			const data: {
				gtfs_realtime_version?: string;
				incrementality?: FeedHeader.Incrementality;
				timestamp?: number;
			} = {};
			if (this.gtfs_realtime_version != null) {
				data.gtfs_realtime_version = this.gtfs_realtime_version;
			}
			if (this.incrementality != null) {
				data.incrementality = this.incrementality;
			}
			if (this.timestamp != null) {
				data.timestamp = this.timestamp;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_gtfs_realtime_version && this.gtfs_realtime_version.length)
				writer.writeString(1, this.gtfs_realtime_version);
			if (this.has_incrementality) writer.writeEnum(2, this.incrementality);
			if (this.has_timestamp) writer.writeUint64(3, this.timestamp);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FeedHeader {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new FeedHeader();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.gtfs_realtime_version = reader.readString();
						break;
					case 2:
						message.incrementality = reader.readEnum();
						break;
					case 3:
						message.timestamp = reader.readUint64();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): FeedHeader {
			return FeedHeader.deserialize(bytes);
		}
	}
	export namespace FeedHeader {
		export enum Incrementality {
			FULL_DATASET = 0,
			DIFFERENTIAL = 1
		}
	}
	export class FeedEntity extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						id: string;
						is_deleted?: boolean;
						trip_update?: TripUpdate;
						vehicle?: VehiclePosition;
						alert?: Alert;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				this.id = data.id;
				if ('is_deleted' in data && data.is_deleted != undefined) {
					this.is_deleted = data.is_deleted;
				}
				if ('trip_update' in data && data.trip_update != undefined) {
					this.trip_update = data.trip_update;
				}
				if ('vehicle' in data && data.vehicle != undefined) {
					this.vehicle = data.vehicle;
				}
				if ('alert' in data && data.alert != undefined) {
					this.alert = data.alert;
				}
			}
		}
		get id() {
			return pb_1.Message.getField(this, 1) as string;
		}
		set id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get has_id() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get is_deleted() {
			return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
		}
		set is_deleted(value: boolean) {
			pb_1.Message.setField(this, 2, value);
		}
		get has_is_deleted() {
			return pb_1.Message.getField(this, 2) != null;
		}
		get trip_update() {
			return pb_1.Message.getWrapperField(this, TripUpdate, 3) as TripUpdate;
		}
		set trip_update(value: TripUpdate) {
			pb_1.Message.setWrapperField(this, 3, value);
		}
		get has_trip_update() {
			return pb_1.Message.getField(this, 3) != null;
		}
		get vehicle() {
			return pb_1.Message.getWrapperField(this, VehiclePosition, 4) as VehiclePosition;
		}
		set vehicle(value: VehiclePosition) {
			pb_1.Message.setWrapperField(this, 4, value);
		}
		get has_vehicle() {
			return pb_1.Message.getField(this, 4) != null;
		}
		get alert() {
			return pb_1.Message.getWrapperField(this, Alert, 5) as Alert;
		}
		set alert(value: Alert) {
			pb_1.Message.setWrapperField(this, 5, value);
		}
		get has_alert() {
			return pb_1.Message.getField(this, 5) != null;
		}
		static fromObject(data: {
			id?: string;
			is_deleted?: boolean;
			trip_update?: ReturnType<typeof TripUpdate.prototype.toObject>;
			vehicle?: ReturnType<typeof VehiclePosition.prototype.toObject>;
			alert?: ReturnType<typeof Alert.prototype.toObject>;
		}): FeedEntity {
			const message = new FeedEntity({
				id: data.id
			});
			if (data.is_deleted != null) {
				message.is_deleted = data.is_deleted;
			}
			if (data.trip_update != null) {
				message.trip_update = TripUpdate.fromObject(data.trip_update);
			}
			if (data.vehicle != null) {
				message.vehicle = VehiclePosition.fromObject(data.vehicle);
			}
			if (data.alert != null) {
				message.alert = Alert.fromObject(data.alert);
			}
			return message;
		}
		toObject() {
			const data: {
				id?: string;
				is_deleted?: boolean;
				trip_update?: ReturnType<typeof TripUpdate.prototype.toObject>;
				vehicle?: ReturnType<typeof VehiclePosition.prototype.toObject>;
				alert?: ReturnType<typeof Alert.prototype.toObject>;
			} = {};
			if (this.id != null) {
				data.id = this.id;
			}
			if (this.is_deleted != null) {
				data.is_deleted = this.is_deleted;
			}
			if (this.trip_update != null) {
				data.trip_update = this.trip_update.toObject();
			}
			if (this.vehicle != null) {
				data.vehicle = this.vehicle.toObject();
			}
			if (this.alert != null) {
				data.alert = this.alert.toObject();
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_id && this.id.length) writer.writeString(1, this.id);
			if (this.has_is_deleted) writer.writeBool(2, this.is_deleted);
			if (this.has_trip_update)
				writer.writeMessage(3, this.trip_update, () => this.trip_update.serialize(writer));
			if (this.has_vehicle)
				writer.writeMessage(4, this.vehicle, () => this.vehicle.serialize(writer));
			if (this.has_alert) writer.writeMessage(5, this.alert, () => this.alert.serialize(writer));
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FeedEntity {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new FeedEntity();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.id = reader.readString();
						break;
					case 2:
						message.is_deleted = reader.readBool();
						break;
					case 3:
						reader.readMessage(
							message.trip_update,
							() => (message.trip_update = TripUpdate.deserialize(reader))
						);
						break;
					case 4:
						reader.readMessage(
							message.vehicle,
							() => (message.vehicle = VehiclePosition.deserialize(reader))
						);
						break;
					case 5:
						reader.readMessage(message.alert, () => (message.alert = Alert.deserialize(reader)));
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): FeedEntity {
			return FeedEntity.deserialize(bytes);
		}
	}
	export class TripUpdate extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						trip: TripDescriptor;
						vehicle?: VehicleDescriptor;
						stop_time_update: TripUpdate.StopTimeUpdate[];
						timestamp?: number;
						delay?: number;
				  }
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[2],
				this.#one_of_decls
			);
			if (!Array.isArray(data) && typeof data == 'object') {
				this.trip = data.trip;
				if ('vehicle' in data && data.vehicle != undefined) {
					this.vehicle = data.vehicle;
				}
				this.stop_time_update = data.stop_time_update;
				if ('timestamp' in data && data.timestamp != undefined) {
					this.timestamp = data.timestamp;
				}
				if ('delay' in data && data.delay != undefined) {
					this.delay = data.delay;
				}
			}
		}
		get trip() {
			return pb_1.Message.getWrapperField(this, TripDescriptor, 1) as TripDescriptor;
		}
		set trip(value: TripDescriptor) {
			pb_1.Message.setWrapperField(this, 1, value);
		}
		get has_trip() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get vehicle() {
			return pb_1.Message.getWrapperField(this, VehicleDescriptor, 3) as VehicleDescriptor;
		}
		set vehicle(value: VehicleDescriptor) {
			pb_1.Message.setWrapperField(this, 3, value);
		}
		get has_vehicle() {
			return pb_1.Message.getField(this, 3) != null;
		}
		get stop_time_update() {
			return pb_1.Message.getRepeatedWrapperField(
				this,
				TripUpdate.StopTimeUpdate,
				2
			) as TripUpdate.StopTimeUpdate[];
		}
		set stop_time_update(value: TripUpdate.StopTimeUpdate[]) {
			pb_1.Message.setRepeatedWrapperField(this, 2, value);
		}
		get timestamp() {
			return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
		}
		set timestamp(value: number) {
			pb_1.Message.setField(this, 4, value);
		}
		get has_timestamp() {
			return pb_1.Message.getField(this, 4) != null;
		}
		get delay() {
			return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
		}
		set delay(value: number) {
			pb_1.Message.setField(this, 5, value);
		}
		get has_delay() {
			return pb_1.Message.getField(this, 5) != null;
		}
		static fromObject(data: {
			trip?: ReturnType<typeof TripDescriptor.prototype.toObject>;
			vehicle?: ReturnType<typeof VehicleDescriptor.prototype.toObject>;
			stop_time_update?: ReturnType<typeof TripUpdate.StopTimeUpdate.prototype.toObject>[];
			timestamp?: number;
			delay?: number;
		}): TripUpdate {
			const message = new TripUpdate({
				trip: TripDescriptor.fromObject(data.trip),
				stop_time_update: data.stop_time_update.map((item) =>
					TripUpdate.StopTimeUpdate.fromObject(item)
				)
			});
			if (data.vehicle != null) {
				message.vehicle = VehicleDescriptor.fromObject(data.vehicle);
			}
			if (data.timestamp != null) {
				message.timestamp = data.timestamp;
			}
			if (data.delay != null) {
				message.delay = data.delay;
			}
			return message;
		}
		toObject() {
			const data: {
				trip?: ReturnType<typeof TripDescriptor.prototype.toObject>;
				vehicle?: ReturnType<typeof VehicleDescriptor.prototype.toObject>;
				stop_time_update?: ReturnType<typeof TripUpdate.StopTimeUpdate.prototype.toObject>[];
				timestamp?: number;
				delay?: number;
			} = {};
			if (this.trip != null) {
				data.trip = this.trip.toObject();
			}
			if (this.vehicle != null) {
				data.vehicle = this.vehicle.toObject();
			}
			if (this.stop_time_update != null) {
				data.stop_time_update = this.stop_time_update.map((item: TripUpdate.StopTimeUpdate) =>
					item.toObject()
				);
			}
			if (this.timestamp != null) {
				data.timestamp = this.timestamp;
			}
			if (this.delay != null) {
				data.delay = this.delay;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_trip) writer.writeMessage(1, this.trip, () => this.trip.serialize(writer));
			if (this.has_vehicle)
				writer.writeMessage(3, this.vehicle, () => this.vehicle.serialize(writer));
			if (this.stop_time_update.length)
				writer.writeRepeatedMessage(2, this.stop_time_update, (item: TripUpdate.StopTimeUpdate) =>
					item.serialize(writer)
				);
			if (this.has_timestamp) writer.writeUint64(4, this.timestamp);
			if (this.has_delay) writer.writeInt32(5, this.delay);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TripUpdate {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new TripUpdate();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						reader.readMessage(
							message.trip,
							() => (message.trip = TripDescriptor.deserialize(reader))
						);
						break;
					case 3:
						reader.readMessage(
							message.vehicle,
							() => (message.vehicle = VehicleDescriptor.deserialize(reader))
						);
						break;
					case 2:
						reader.readMessage(message.stop_time_update, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								2,
								TripUpdate.StopTimeUpdate.deserialize(reader),
								TripUpdate.StopTimeUpdate
							)
						);
						break;
					case 4:
						message.timestamp = reader.readUint64();
						break;
					case 5:
						message.delay = reader.readInt32();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TripUpdate {
			return TripUpdate.deserialize(bytes);
		}
	}
	export namespace TripUpdate {
		export class StopTimeEvent extends pb_1.Message {
			#one_of_decls: number[][] = [];
			constructor(
				data?:
					| any[]
					| {
							delay?: number;
							time?: number;
							uncertainty?: number;
					  }
			) {
				super();
				pb_1.Message.initialize(
					this,
					Array.isArray(data) ? data : [],
					0,
					-1,
					[],
					this.#one_of_decls
				);
				if (!Array.isArray(data) && typeof data == 'object') {
					if ('delay' in data && data.delay != undefined) {
						this.delay = data.delay;
					}
					if ('time' in data && data.time != undefined) {
						this.time = data.time;
					}
					if ('uncertainty' in data && data.uncertainty != undefined) {
						this.uncertainty = data.uncertainty;
					}
				}
			}
			get delay() {
				return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
			}
			set delay(value: number) {
				pb_1.Message.setField(this, 1, value);
			}
			get has_delay() {
				return pb_1.Message.getField(this, 1) != null;
			}
			get time() {
				return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
			}
			set time(value: number) {
				pb_1.Message.setField(this, 2, value);
			}
			get has_time() {
				return pb_1.Message.getField(this, 2) != null;
			}
			get uncertainty() {
				return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
			}
			set uncertainty(value: number) {
				pb_1.Message.setField(this, 3, value);
			}
			get has_uncertainty() {
				return pb_1.Message.getField(this, 3) != null;
			}
			static fromObject(data: {
				delay?: number;
				time?: number;
				uncertainty?: number;
			}): StopTimeEvent {
				const message = new StopTimeEvent({});
				if (data.delay != null) {
					message.delay = data.delay;
				}
				if (data.time != null) {
					message.time = data.time;
				}
				if (data.uncertainty != null) {
					message.uncertainty = data.uncertainty;
				}
				return message;
			}
			toObject() {
				const data: {
					delay?: number;
					time?: number;
					uncertainty?: number;
				} = {};
				if (this.delay != null) {
					data.delay = this.delay;
				}
				if (this.time != null) {
					data.time = this.time;
				}
				if (this.uncertainty != null) {
					data.uncertainty = this.uncertainty;
				}
				return data;
			}
			serialize(): Uint8Array;
			serialize(w: pb_1.BinaryWriter): void;
			serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
				const writer = w || new pb_1.BinaryWriter();
				if (this.has_delay) writer.writeInt32(1, this.delay);
				if (this.has_time) writer.writeInt64(2, this.time);
				if (this.has_uncertainty) writer.writeInt32(3, this.uncertainty);
				if (!w) return writer.getResultBuffer();
			}
			static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StopTimeEvent {
				const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
					message = new StopTimeEvent();
				while (reader.nextField()) {
					if (reader.isEndGroup()) break;
					switch (reader.getFieldNumber()) {
						case 1:
							message.delay = reader.readInt32();
							break;
						case 2:
							message.time = reader.readInt64();
							break;
						case 3:
							message.uncertainty = reader.readInt32();
							break;
						default:
							reader.skipField();
					}
				}
				return message;
			}
			serializeBinary(): Uint8Array {
				return this.serialize();
			}
			static deserializeBinary(bytes: Uint8Array): StopTimeEvent {
				return StopTimeEvent.deserialize(bytes);
			}
		}
		export class StopTimeUpdate extends pb_1.Message {
			#one_of_decls: number[][] = [];
			constructor(
				data?:
					| any[]
					| {
							stop_sequence?: number;
							stop_id?: string;
							arrival?: TripUpdate.StopTimeEvent;
							departure?: TripUpdate.StopTimeEvent;
							schedule_relationship?: TripUpdate.StopTimeUpdate.ScheduleRelationship;
					  }
			) {
				super();
				pb_1.Message.initialize(
					this,
					Array.isArray(data) ? data : [],
					0,
					-1,
					[],
					this.#one_of_decls
				);
				if (!Array.isArray(data) && typeof data == 'object') {
					if ('stop_sequence' in data && data.stop_sequence != undefined) {
						this.stop_sequence = data.stop_sequence;
					}
					if ('stop_id' in data && data.stop_id != undefined) {
						this.stop_id = data.stop_id;
					}
					if ('arrival' in data && data.arrival != undefined) {
						this.arrival = data.arrival;
					}
					if ('departure' in data && data.departure != undefined) {
						this.departure = data.departure;
					}
					if ('schedule_relationship' in data && data.schedule_relationship != undefined) {
						this.schedule_relationship = data.schedule_relationship;
					}
				}
			}
			get stop_sequence() {
				return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
			}
			set stop_sequence(value: number) {
				pb_1.Message.setField(this, 1, value);
			}
			get has_stop_sequence() {
				return pb_1.Message.getField(this, 1) != null;
			}
			get stop_id() {
				return pb_1.Message.getFieldWithDefault(this, 4, '') as string;
			}
			set stop_id(value: string) {
				pb_1.Message.setField(this, 4, value);
			}
			get has_stop_id() {
				return pb_1.Message.getField(this, 4) != null;
			}
			get arrival() {
				return pb_1.Message.getWrapperField(
					this,
					TripUpdate.StopTimeEvent,
					2
				) as TripUpdate.StopTimeEvent;
			}
			set arrival(value: TripUpdate.StopTimeEvent) {
				pb_1.Message.setWrapperField(this, 2, value);
			}
			get has_arrival() {
				return pb_1.Message.getField(this, 2) != null;
			}
			get departure() {
				return pb_1.Message.getWrapperField(
					this,
					TripUpdate.StopTimeEvent,
					3
				) as TripUpdate.StopTimeEvent;
			}
			set departure(value: TripUpdate.StopTimeEvent) {
				pb_1.Message.setWrapperField(this, 3, value);
			}
			get has_departure() {
				return pb_1.Message.getField(this, 3) != null;
			}
			get schedule_relationship() {
				return pb_1.Message.getFieldWithDefault(
					this,
					5,
					TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED
				) as TripUpdate.StopTimeUpdate.ScheduleRelationship;
			}
			set schedule_relationship(value: TripUpdate.StopTimeUpdate.ScheduleRelationship) {
				pb_1.Message.setField(this, 5, value);
			}
			get has_schedule_relationship() {
				return pb_1.Message.getField(this, 5) != null;
			}
			static fromObject(data: {
				stop_sequence?: number;
				stop_id?: string;
				arrival?: ReturnType<typeof TripUpdate.StopTimeEvent.prototype.toObject>;
				departure?: ReturnType<typeof TripUpdate.StopTimeEvent.prototype.toObject>;
				schedule_relationship?: TripUpdate.StopTimeUpdate.ScheduleRelationship;
			}): StopTimeUpdate {
				const message = new StopTimeUpdate({});
				if (data.stop_sequence != null) {
					message.stop_sequence = data.stop_sequence;
				}
				if (data.stop_id != null) {
					message.stop_id = data.stop_id;
				}
				if (data.arrival != null) {
					message.arrival = TripUpdate.StopTimeEvent.fromObject(data.arrival);
				}
				if (data.departure != null) {
					message.departure = TripUpdate.StopTimeEvent.fromObject(data.departure);
				}
				if (data.schedule_relationship != null) {
					message.schedule_relationship = data.schedule_relationship;
				}
				return message;
			}
			toObject() {
				const data: {
					stop_sequence?: number;
					stop_id?: string;
					arrival?: ReturnType<typeof TripUpdate.StopTimeEvent.prototype.toObject>;
					departure?: ReturnType<typeof TripUpdate.StopTimeEvent.prototype.toObject>;
					schedule_relationship?: TripUpdate.StopTimeUpdate.ScheduleRelationship;
				} = {};
				if (this.stop_sequence != null) {
					data.stop_sequence = this.stop_sequence;
				}
				if (this.stop_id != null) {
					data.stop_id = this.stop_id;
				}
				if (this.arrival != null) {
					data.arrival = this.arrival.toObject();
				}
				if (this.departure != null) {
					data.departure = this.departure.toObject();
				}
				if (this.schedule_relationship != null) {
					data.schedule_relationship = this.schedule_relationship;
				}
				return data;
			}
			serialize(): Uint8Array;
			serialize(w: pb_1.BinaryWriter): void;
			serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
				const writer = w || new pb_1.BinaryWriter();
				if (this.has_stop_sequence) writer.writeUint32(1, this.stop_sequence);
				if (this.has_stop_id && this.stop_id.length) writer.writeString(4, this.stop_id);
				if (this.has_arrival)
					writer.writeMessage(2, this.arrival, () => this.arrival.serialize(writer));
				if (this.has_departure)
					writer.writeMessage(3, this.departure, () => this.departure.serialize(writer));
				if (this.has_schedule_relationship) writer.writeEnum(5, this.schedule_relationship);
				if (!w) return writer.getResultBuffer();
			}
			static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StopTimeUpdate {
				const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
					message = new StopTimeUpdate();
				while (reader.nextField()) {
					if (reader.isEndGroup()) break;
					switch (reader.getFieldNumber()) {
						case 1:
							message.stop_sequence = reader.readUint32();
							break;
						case 4:
							message.stop_id = reader.readString();
							break;
						case 2:
							reader.readMessage(
								message.arrival,
								() => (message.arrival = TripUpdate.StopTimeEvent.deserialize(reader))
							);
							break;
						case 3:
							reader.readMessage(
								message.departure,
								() => (message.departure = TripUpdate.StopTimeEvent.deserialize(reader))
							);
							break;
						case 5:
							message.schedule_relationship = reader.readEnum();
							break;
						default:
							reader.skipField();
					}
				}
				return message;
			}
			serializeBinary(): Uint8Array {
				return this.serialize();
			}
			static deserializeBinary(bytes: Uint8Array): StopTimeUpdate {
				return StopTimeUpdate.deserialize(bytes);
			}
		}
		export namespace StopTimeUpdate {
			export enum ScheduleRelationship {
				SCHEDULED = 0,
				SKIPPED = 1,
				NO_DATA = 2
			}
		}
	}
	export class VehiclePosition extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						trip?: TripDescriptor;
						vehicle?: VehicleDescriptor;
						position?: Position;
						current_stop_sequence?: number;
						stop_id?: string;
						current_status?: VehiclePosition.VehicleStopStatus;
						timestamp?: number;
						congestion_level?: VehiclePosition.CongestionLevel;
						occupancy_status?: VehiclePosition.OccupancyStatus;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				if ('trip' in data && data.trip != undefined) {
					this.trip = data.trip;
				}
				if ('vehicle' in data && data.vehicle != undefined) {
					this.vehicle = data.vehicle;
				}
				if ('position' in data && data.position != undefined) {
					this.position = data.position;
				}
				if ('current_stop_sequence' in data && data.current_stop_sequence != undefined) {
					this.current_stop_sequence = data.current_stop_sequence;
				}
				if ('stop_id' in data && data.stop_id != undefined) {
					this.stop_id = data.stop_id;
				}
				if ('current_status' in data && data.current_status != undefined) {
					this.current_status = data.current_status;
				}
				if ('timestamp' in data && data.timestamp != undefined) {
					this.timestamp = data.timestamp;
				}
				if ('congestion_level' in data && data.congestion_level != undefined) {
					this.congestion_level = data.congestion_level;
				}
				if ('occupancy_status' in data && data.occupancy_status != undefined) {
					this.occupancy_status = data.occupancy_status;
				}
			}
		}
		get trip() {
			return pb_1.Message.getWrapperField(this, TripDescriptor, 1) as TripDescriptor;
		}
		set trip(value: TripDescriptor) {
			pb_1.Message.setWrapperField(this, 1, value);
		}
		get has_trip() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get vehicle() {
			return pb_1.Message.getWrapperField(this, VehicleDescriptor, 8) as VehicleDescriptor;
		}
		set vehicle(value: VehicleDescriptor) {
			pb_1.Message.setWrapperField(this, 8, value);
		}
		get has_vehicle() {
			return pb_1.Message.getField(this, 8) != null;
		}
		get position() {
			return pb_1.Message.getWrapperField(this, Position, 2) as Position;
		}
		set position(value: Position) {
			pb_1.Message.setWrapperField(this, 2, value);
		}
		get has_position() {
			return pb_1.Message.getField(this, 2) != null;
		}
		get current_stop_sequence() {
			return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
		}
		set current_stop_sequence(value: number) {
			pb_1.Message.setField(this, 3, value);
		}
		get has_current_stop_sequence() {
			return pb_1.Message.getField(this, 3) != null;
		}
		get stop_id() {
			return pb_1.Message.getFieldWithDefault(this, 7, '') as string;
		}
		set stop_id(value: string) {
			pb_1.Message.setField(this, 7, value);
		}
		get has_stop_id() {
			return pb_1.Message.getField(this, 7) != null;
		}
		get current_status() {
			return pb_1.Message.getFieldWithDefault(
				this,
				4,
				VehiclePosition.VehicleStopStatus.IN_TRANSIT_TO
			) as VehiclePosition.VehicleStopStatus;
		}
		set current_status(value: VehiclePosition.VehicleStopStatus) {
			pb_1.Message.setField(this, 4, value);
		}
		get has_current_status() {
			return pb_1.Message.getField(this, 4) != null;
		}
		get timestamp() {
			return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
		}
		set timestamp(value: number) {
			pb_1.Message.setField(this, 5, value);
		}
		get has_timestamp() {
			return pb_1.Message.getField(this, 5) != null;
		}
		get congestion_level() {
			return pb_1.Message.getFieldWithDefault(
				this,
				6,
				VehiclePosition.CongestionLevel.UNKNOWN_CONGESTION_LEVEL
			) as VehiclePosition.CongestionLevel;
		}
		set congestion_level(value: VehiclePosition.CongestionLevel) {
			pb_1.Message.setField(this, 6, value);
		}
		get has_congestion_level() {
			return pb_1.Message.getField(this, 6) != null;
		}
		get occupancy_status() {
			return pb_1.Message.getFieldWithDefault(
				this,
				9,
				VehiclePosition.OccupancyStatus.EMPTY
			) as VehiclePosition.OccupancyStatus;
		}
		set occupancy_status(value: VehiclePosition.OccupancyStatus) {
			pb_1.Message.setField(this, 9, value);
		}
		get has_occupancy_status() {
			return pb_1.Message.getField(this, 9) != null;
		}
		static fromObject(data: {
			trip?: ReturnType<typeof TripDescriptor.prototype.toObject>;
			vehicle?: ReturnType<typeof VehicleDescriptor.prototype.toObject>;
			position?: ReturnType<typeof Position.prototype.toObject>;
			current_stop_sequence?: number;
			stop_id?: string;
			current_status?: VehiclePosition.VehicleStopStatus;
			timestamp?: number;
			congestion_level?: VehiclePosition.CongestionLevel;
			occupancy_status?: VehiclePosition.OccupancyStatus;
		}): VehiclePosition {
			const message = new VehiclePosition({});
			if (data.trip != null) {
				message.trip = TripDescriptor.fromObject(data.trip);
			}
			if (data.vehicle != null) {
				message.vehicle = VehicleDescriptor.fromObject(data.vehicle);
			}
			if (data.position != null) {
				message.position = Position.fromObject(data.position);
			}
			if (data.current_stop_sequence != null) {
				message.current_stop_sequence = data.current_stop_sequence;
			}
			if (data.stop_id != null) {
				message.stop_id = data.stop_id;
			}
			if (data.current_status != null) {
				message.current_status = data.current_status;
			}
			if (data.timestamp != null) {
				message.timestamp = data.timestamp;
			}
			if (data.congestion_level != null) {
				message.congestion_level = data.congestion_level;
			}
			if (data.occupancy_status != null) {
				message.occupancy_status = data.occupancy_status;
			}
			return message;
		}
		toObject() {
			const data: {
				trip?: ReturnType<typeof TripDescriptor.prototype.toObject>;
				vehicle?: ReturnType<typeof VehicleDescriptor.prototype.toObject>;
				position?: ReturnType<typeof Position.prototype.toObject>;
				current_stop_sequence?: number;
				stop_id?: string;
				current_status?: VehiclePosition.VehicleStopStatus;
				timestamp?: number;
				congestion_level?: VehiclePosition.CongestionLevel;
				occupancy_status?: VehiclePosition.OccupancyStatus;
			} = {};
			if (this.trip != null) {
				data.trip = this.trip.toObject();
			}
			if (this.vehicle != null) {
				data.vehicle = this.vehicle.toObject();
			}
			if (this.position != null) {
				data.position = this.position.toObject();
			}
			if (this.current_stop_sequence != null) {
				data.current_stop_sequence = this.current_stop_sequence;
			}
			if (this.stop_id != null) {
				data.stop_id = this.stop_id;
			}
			if (this.current_status != null) {
				data.current_status = this.current_status;
			}
			if (this.timestamp != null) {
				data.timestamp = this.timestamp;
			}
			if (this.congestion_level != null) {
				data.congestion_level = this.congestion_level;
			}
			if (this.occupancy_status != null) {
				data.occupancy_status = this.occupancy_status;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_trip) writer.writeMessage(1, this.trip, () => this.trip.serialize(writer));
			if (this.has_vehicle)
				writer.writeMessage(8, this.vehicle, () => this.vehicle.serialize(writer));
			if (this.has_position)
				writer.writeMessage(2, this.position, () => this.position.serialize(writer));
			if (this.has_current_stop_sequence) writer.writeUint32(3, this.current_stop_sequence);
			if (this.has_stop_id && this.stop_id.length) writer.writeString(7, this.stop_id);
			if (this.has_current_status) writer.writeEnum(4, this.current_status);
			if (this.has_timestamp) writer.writeUint64(5, this.timestamp);
			if (this.has_congestion_level) writer.writeEnum(6, this.congestion_level);
			if (this.has_occupancy_status) writer.writeEnum(9, this.occupancy_status);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VehiclePosition {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new VehiclePosition();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						reader.readMessage(
							message.trip,
							() => (message.trip = TripDescriptor.deserialize(reader))
						);
						break;
					case 8:
						reader.readMessage(
							message.vehicle,
							() => (message.vehicle = VehicleDescriptor.deserialize(reader))
						);
						break;
					case 2:
						reader.readMessage(
							message.position,
							() => (message.position = Position.deserialize(reader))
						);
						break;
					case 3:
						message.current_stop_sequence = reader.readUint32();
						break;
					case 7:
						message.stop_id = reader.readString();
						break;
					case 4:
						message.current_status = reader.readEnum();
						break;
					case 5:
						message.timestamp = reader.readUint64();
						break;
					case 6:
						message.congestion_level = reader.readEnum();
						break;
					case 9:
						message.occupancy_status = reader.readEnum();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): VehiclePosition {
			return VehiclePosition.deserialize(bytes);
		}
	}
	export namespace VehiclePosition {
		export enum VehicleStopStatus {
			INCOMING_AT = 0,
			STOPPED_AT = 1,
			IN_TRANSIT_TO = 2
		}
		export enum CongestionLevel {
			UNKNOWN_CONGESTION_LEVEL = 0,
			RUNNING_SMOOTHLY = 1,
			STOP_AND_GO = 2,
			CONGESTION = 3,
			SEVERE_CONGESTION = 4
		}
		export enum OccupancyStatus {
			EMPTY = 0,
			MANY_SEATS_AVAILABLE = 1,
			FEW_SEATS_AVAILABLE = 2,
			STANDING_ROOM_ONLY = 3,
			CRUSHED_STANDING_ROOM_ONLY = 4,
			FULL = 5,
			NOT_ACCEPTING_PASSENGERS = 6
		}
	}
	export class Alert extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						active_period: TimeRange[];
						informed_entity: EntitySelector[];
						cause?: Alert.Cause;
						effect?: Alert.Effect;
						url?: TranslatedString;
						header_text?: TranslatedString;
						description_text?: TranslatedString;
				  }
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[1, 5],
				this.#one_of_decls
			);
			if (!Array.isArray(data) && typeof data == 'object') {
				this.active_period = data.active_period;
				this.informed_entity = data.informed_entity;
				if ('cause' in data && data.cause != undefined) {
					this.cause = data.cause;
				}
				if ('effect' in data && data.effect != undefined) {
					this.effect = data.effect;
				}
				if ('url' in data && data.url != undefined) {
					this.url = data.url;
				}
				if ('header_text' in data && data.header_text != undefined) {
					this.header_text = data.header_text;
				}
				if ('description_text' in data && data.description_text != undefined) {
					this.description_text = data.description_text;
				}
			}
		}
		get active_period() {
			return pb_1.Message.getRepeatedWrapperField(this, TimeRange, 1) as TimeRange[];
		}
		set active_period(value: TimeRange[]) {
			pb_1.Message.setRepeatedWrapperField(this, 1, value);
		}
		get informed_entity() {
			return pb_1.Message.getRepeatedWrapperField(this, EntitySelector, 5) as EntitySelector[];
		}
		set informed_entity(value: EntitySelector[]) {
			pb_1.Message.setRepeatedWrapperField(this, 5, value);
		}
		get cause() {
			return pb_1.Message.getFieldWithDefault(this, 6, Alert.Cause.UNKNOWN_CAUSE) as Alert.Cause;
		}
		set cause(value: Alert.Cause) {
			pb_1.Message.setField(this, 6, value);
		}
		get has_cause() {
			return pb_1.Message.getField(this, 6) != null;
		}
		get effect() {
			return pb_1.Message.getFieldWithDefault(this, 7, Alert.Effect.UNKNOWN_EFFECT) as Alert.Effect;
		}
		set effect(value: Alert.Effect) {
			pb_1.Message.setField(this, 7, value);
		}
		get has_effect() {
			return pb_1.Message.getField(this, 7) != null;
		}
		get url() {
			return pb_1.Message.getWrapperField(this, TranslatedString, 8) as TranslatedString;
		}
		set url(value: TranslatedString) {
			pb_1.Message.setWrapperField(this, 8, value);
		}
		get has_url() {
			return pb_1.Message.getField(this, 8) != null;
		}
		get header_text() {
			return pb_1.Message.getWrapperField(this, TranslatedString, 10) as TranslatedString;
		}
		set header_text(value: TranslatedString) {
			pb_1.Message.setWrapperField(this, 10, value);
		}
		get has_header_text() {
			return pb_1.Message.getField(this, 10) != null;
		}
		get description_text() {
			return pb_1.Message.getWrapperField(this, TranslatedString, 11) as TranslatedString;
		}
		set description_text(value: TranslatedString) {
			pb_1.Message.setWrapperField(this, 11, value);
		}
		get has_description_text() {
			return pb_1.Message.getField(this, 11) != null;
		}
		static fromObject(data: {
			active_period?: ReturnType<typeof TimeRange.prototype.toObject>[];
			informed_entity?: ReturnType<typeof EntitySelector.prototype.toObject>[];
			cause?: Alert.Cause;
			effect?: Alert.Effect;
			url?: ReturnType<typeof TranslatedString.prototype.toObject>;
			header_text?: ReturnType<typeof TranslatedString.prototype.toObject>;
			description_text?: ReturnType<typeof TranslatedString.prototype.toObject>;
		}): Alert {
			const message = new Alert({
				active_period: data.active_period.map((item) => TimeRange.fromObject(item)),
				informed_entity: data.informed_entity.map((item) => EntitySelector.fromObject(item))
			});
			if (data.cause != null) {
				message.cause = data.cause;
			}
			if (data.effect != null) {
				message.effect = data.effect;
			}
			if (data.url != null) {
				message.url = TranslatedString.fromObject(data.url);
			}
			if (data.header_text != null) {
				message.header_text = TranslatedString.fromObject(data.header_text);
			}
			if (data.description_text != null) {
				message.description_text = TranslatedString.fromObject(data.description_text);
			}
			return message;
		}
		toObject() {
			const data: {
				active_period?: ReturnType<typeof TimeRange.prototype.toObject>[];
				informed_entity?: ReturnType<typeof EntitySelector.prototype.toObject>[];
				cause?: Alert.Cause;
				effect?: Alert.Effect;
				url?: ReturnType<typeof TranslatedString.prototype.toObject>;
				header_text?: ReturnType<typeof TranslatedString.prototype.toObject>;
				description_text?: ReturnType<typeof TranslatedString.prototype.toObject>;
			} = {};
			if (this.active_period != null) {
				data.active_period = this.active_period.map((item: TimeRange) => item.toObject());
			}
			if (this.informed_entity != null) {
				data.informed_entity = this.informed_entity.map((item: EntitySelector) => item.toObject());
			}
			if (this.cause != null) {
				data.cause = this.cause;
			}
			if (this.effect != null) {
				data.effect = this.effect;
			}
			if (this.url != null) {
				data.url = this.url.toObject();
			}
			if (this.header_text != null) {
				data.header_text = this.header_text.toObject();
			}
			if (this.description_text != null) {
				data.description_text = this.description_text.toObject();
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.active_period.length)
				writer.writeRepeatedMessage(1, this.active_period, (item: TimeRange) =>
					item.serialize(writer)
				);
			if (this.informed_entity.length)
				writer.writeRepeatedMessage(5, this.informed_entity, (item: EntitySelector) =>
					item.serialize(writer)
				);
			if (this.has_cause) writer.writeEnum(6, this.cause);
			if (this.has_effect) writer.writeEnum(7, this.effect);
			if (this.has_url) writer.writeMessage(8, this.url, () => this.url.serialize(writer));
			if (this.has_header_text)
				writer.writeMessage(10, this.header_text, () => this.header_text.serialize(writer));
			if (this.has_description_text)
				writer.writeMessage(11, this.description_text, () =>
					this.description_text.serialize(writer)
				);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Alert {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Alert();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						reader.readMessage(message.active_period, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								1,
								TimeRange.deserialize(reader),
								TimeRange
							)
						);
						break;
					case 5:
						reader.readMessage(message.informed_entity, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								5,
								EntitySelector.deserialize(reader),
								EntitySelector
							)
						);
						break;
					case 6:
						message.cause = reader.readEnum();
						break;
					case 7:
						message.effect = reader.readEnum();
						break;
					case 8:
						reader.readMessage(
							message.url,
							() => (message.url = TranslatedString.deserialize(reader))
						);
						break;
					case 10:
						reader.readMessage(
							message.header_text,
							() => (message.header_text = TranslatedString.deserialize(reader))
						);
						break;
					case 11:
						reader.readMessage(
							message.description_text,
							() => (message.description_text = TranslatedString.deserialize(reader))
						);
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Alert {
			return Alert.deserialize(bytes);
		}
	}
	export namespace Alert {
		export enum Cause {
			UNKNOWN_CAUSE = 1,
			OTHER_CAUSE = 2,
			TECHNICAL_PROBLEM = 3,
			STRIKE = 4,
			DEMONSTRATION = 5,
			ACCIDENT = 6,
			HOLIDAY = 7,
			WEATHER = 8,
			MAINTENANCE = 9,
			CONSTRUCTION = 10,
			POLICE_ACTIVITY = 11,
			MEDICAL_EMERGENCY = 12
		}
		export enum Effect {
			NO_SERVICE = 1,
			REDUCED_SERVICE = 2,
			SIGNIFICANT_DELAYS = 3,
			DETOUR = 4,
			ADDITIONAL_SERVICE = 5,
			MODIFIED_SERVICE = 6,
			OTHER_EFFECT = 7,
			UNKNOWN_EFFECT = 8,
			STOP_MOVED = 9
		}
	}
	export class TimeRange extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						start?: number;
						end?: number;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				if ('start' in data && data.start != undefined) {
					this.start = data.start;
				}
				if ('end' in data && data.end != undefined) {
					this.end = data.end;
				}
			}
		}
		get start() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set start(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		get has_start() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get end() {
			return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
		}
		set end(value: number) {
			pb_1.Message.setField(this, 2, value);
		}
		get has_end() {
			return pb_1.Message.getField(this, 2) != null;
		}
		static fromObject(data: { start?: number; end?: number }): TimeRange {
			const message = new TimeRange({});
			if (data.start != null) {
				message.start = data.start;
			}
			if (data.end != null) {
				message.end = data.end;
			}
			return message;
		}
		toObject() {
			const data: {
				start?: number;
				end?: number;
			} = {};
			if (this.start != null) {
				data.start = this.start;
			}
			if (this.end != null) {
				data.end = this.end;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_start) writer.writeUint64(1, this.start);
			if (this.has_end) writer.writeUint64(2, this.end);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TimeRange {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new TimeRange();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.start = reader.readUint64();
						break;
					case 2:
						message.end = reader.readUint64();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TimeRange {
			return TimeRange.deserialize(bytes);
		}
	}
	export class Position extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						latitude: number;
						longitude: number;
						bearing?: number;
						odometer?: number;
						speed?: number;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				this.latitude = data.latitude;
				this.longitude = data.longitude;
				if ('bearing' in data && data.bearing != undefined) {
					this.bearing = data.bearing;
				}
				if ('odometer' in data && data.odometer != undefined) {
					this.odometer = data.odometer;
				}
				if ('speed' in data && data.speed != undefined) {
					this.speed = data.speed;
				}
			}
		}
		get latitude() {
			return pb_1.Message.getField(this, 1) as number;
		}
		set latitude(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		get has_latitude() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get longitude() {
			return pb_1.Message.getField(this, 2) as number;
		}
		set longitude(value: number) {
			pb_1.Message.setField(this, 2, value);
		}
		get has_longitude() {
			return pb_1.Message.getField(this, 2) != null;
		}
		get bearing() {
			return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
		}
		set bearing(value: number) {
			pb_1.Message.setField(this, 3, value);
		}
		get has_bearing() {
			return pb_1.Message.getField(this, 3) != null;
		}
		get odometer() {
			return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
		}
		set odometer(value: number) {
			pb_1.Message.setField(this, 4, value);
		}
		get has_odometer() {
			return pb_1.Message.getField(this, 4) != null;
		}
		get speed() {
			return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
		}
		set speed(value: number) {
			pb_1.Message.setField(this, 5, value);
		}
		get has_speed() {
			return pb_1.Message.getField(this, 5) != null;
		}
		static fromObject(data: {
			latitude?: number;
			longitude?: number;
			bearing?: number;
			odometer?: number;
			speed?: number;
		}): Position {
			const message = new Position({
				latitude: data.latitude,
				longitude: data.longitude
			});
			if (data.bearing != null) {
				message.bearing = data.bearing;
			}
			if (data.odometer != null) {
				message.odometer = data.odometer;
			}
			if (data.speed != null) {
				message.speed = data.speed;
			}
			return message;
		}
		toObject() {
			const data: {
				latitude?: number;
				longitude?: number;
				bearing?: number;
				odometer?: number;
				speed?: number;
			} = {};
			if (this.latitude != null) {
				data.latitude = this.latitude;
			}
			if (this.longitude != null) {
				data.longitude = this.longitude;
			}
			if (this.bearing != null) {
				data.bearing = this.bearing;
			}
			if (this.odometer != null) {
				data.odometer = this.odometer;
			}
			if (this.speed != null) {
				data.speed = this.speed;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_latitude) writer.writeFloat(1, this.latitude);
			if (this.has_longitude) writer.writeFloat(2, this.longitude);
			if (this.has_bearing) writer.writeFloat(3, this.bearing);
			if (this.has_odometer) writer.writeDouble(4, this.odometer);
			if (this.has_speed) writer.writeFloat(5, this.speed);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Position {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Position();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.latitude = reader.readFloat();
						break;
					case 2:
						message.longitude = reader.readFloat();
						break;
					case 3:
						message.bearing = reader.readFloat();
						break;
					case 4:
						message.odometer = reader.readDouble();
						break;
					case 5:
						message.speed = reader.readFloat();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Position {
			return Position.deserialize(bytes);
		}
	}
	export class TripDescriptor extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						trip_id?: string;
						route_id?: string;
						direction_id?: number;
						start_time?: string;
						start_date?: string;
						schedule_relationship?: TripDescriptor.ScheduleRelationship;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				if ('trip_id' in data && data.trip_id != undefined) {
					this.trip_id = data.trip_id;
				}
				if ('route_id' in data && data.route_id != undefined) {
					this.route_id = data.route_id;
				}
				if ('direction_id' in data && data.direction_id != undefined) {
					this.direction_id = data.direction_id;
				}
				if ('start_time' in data && data.start_time != undefined) {
					this.start_time = data.start_time;
				}
				if ('start_date' in data && data.start_date != undefined) {
					this.start_date = data.start_date;
				}
				if ('schedule_relationship' in data && data.schedule_relationship != undefined) {
					this.schedule_relationship = data.schedule_relationship;
				}
			}
		}
		get trip_id() {
			return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
		}
		set trip_id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get has_trip_id() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get route_id() {
			return pb_1.Message.getFieldWithDefault(this, 5, '') as string;
		}
		set route_id(value: string) {
			pb_1.Message.setField(this, 5, value);
		}
		get has_route_id() {
			return pb_1.Message.getField(this, 5) != null;
		}
		get direction_id() {
			return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
		}
		set direction_id(value: number) {
			pb_1.Message.setField(this, 6, value);
		}
		get has_direction_id() {
			return pb_1.Message.getField(this, 6) != null;
		}
		get start_time() {
			return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
		}
		set start_time(value: string) {
			pb_1.Message.setField(this, 2, value);
		}
		get has_start_time() {
			return pb_1.Message.getField(this, 2) != null;
		}
		get start_date() {
			return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
		}
		set start_date(value: string) {
			pb_1.Message.setField(this, 3, value);
		}
		get has_start_date() {
			return pb_1.Message.getField(this, 3) != null;
		}
		get schedule_relationship() {
			return pb_1.Message.getFieldWithDefault(
				this,
				4,
				TripDescriptor.ScheduleRelationship.SCHEDULED
			) as TripDescriptor.ScheduleRelationship;
		}
		set schedule_relationship(value: TripDescriptor.ScheduleRelationship) {
			pb_1.Message.setField(this, 4, value);
		}
		get has_schedule_relationship() {
			return pb_1.Message.getField(this, 4) != null;
		}
		static fromObject(data: {
			trip_id?: string;
			route_id?: string;
			direction_id?: number;
			start_time?: string;
			start_date?: string;
			schedule_relationship?: TripDescriptor.ScheduleRelationship;
		}): TripDescriptor {
			const message = new TripDescriptor({});
			if (data.trip_id != null) {
				message.trip_id = data.trip_id;
			}
			if (data.route_id != null) {
				message.route_id = data.route_id;
			}
			if (data.direction_id != null) {
				message.direction_id = data.direction_id;
			}
			if (data.start_time != null) {
				message.start_time = data.start_time;
			}
			if (data.start_date != null) {
				message.start_date = data.start_date;
			}
			if (data.schedule_relationship != null) {
				message.schedule_relationship = data.schedule_relationship;
			}
			return message;
		}
		toObject() {
			const data: {
				trip_id?: string;
				route_id?: string;
				direction_id?: number;
				start_time?: string;
				start_date?: string;
				schedule_relationship?: TripDescriptor.ScheduleRelationship;
			} = {};
			if (this.trip_id != null) {
				data.trip_id = this.trip_id;
			}
			if (this.route_id != null) {
				data.route_id = this.route_id;
			}
			if (this.direction_id != null) {
				data.direction_id = this.direction_id;
			}
			if (this.start_time != null) {
				data.start_time = this.start_time;
			}
			if (this.start_date != null) {
				data.start_date = this.start_date;
			}
			if (this.schedule_relationship != null) {
				data.schedule_relationship = this.schedule_relationship;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_trip_id && this.trip_id.length) writer.writeString(1, this.trip_id);
			if (this.has_route_id && this.route_id.length) writer.writeString(5, this.route_id);
			if (this.has_direction_id) writer.writeUint32(6, this.direction_id);
			if (this.has_start_time && this.start_time.length) writer.writeString(2, this.start_time);
			if (this.has_start_date && this.start_date.length) writer.writeString(3, this.start_date);
			if (this.has_schedule_relationship) writer.writeEnum(4, this.schedule_relationship);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TripDescriptor {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new TripDescriptor();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.trip_id = reader.readString();
						break;
					case 5:
						message.route_id = reader.readString();
						break;
					case 6:
						message.direction_id = reader.readUint32();
						break;
					case 2:
						message.start_time = reader.readString();
						break;
					case 3:
						message.start_date = reader.readString();
						break;
					case 4:
						message.schedule_relationship = reader.readEnum();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TripDescriptor {
			return TripDescriptor.deserialize(bytes);
		}
	}
	export namespace TripDescriptor {
		export enum ScheduleRelationship {
			SCHEDULED = 0,
			ADDED = 1,
			UNSCHEDULED = 2,
			CANCELED = 3
		}
	}
	export class VehicleDescriptor extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						id?: string;
						label?: string;
						license_plate?: string;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				if ('id' in data && data.id != undefined) {
					this.id = data.id;
				}
				if ('label' in data && data.label != undefined) {
					this.label = data.label;
				}
				if ('license_plate' in data && data.license_plate != undefined) {
					this.license_plate = data.license_plate;
				}
			}
		}
		get id() {
			return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
		}
		set id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get has_id() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get label() {
			return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
		}
		set label(value: string) {
			pb_1.Message.setField(this, 2, value);
		}
		get has_label() {
			return pb_1.Message.getField(this, 2) != null;
		}
		get license_plate() {
			return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
		}
		set license_plate(value: string) {
			pb_1.Message.setField(this, 3, value);
		}
		get has_license_plate() {
			return pb_1.Message.getField(this, 3) != null;
		}
		static fromObject(data: {
			id?: string;
			label?: string;
			license_plate?: string;
		}): VehicleDescriptor {
			const message = new VehicleDescriptor({});
			if (data.id != null) {
				message.id = data.id;
			}
			if (data.label != null) {
				message.label = data.label;
			}
			if (data.license_plate != null) {
				message.license_plate = data.license_plate;
			}
			return message;
		}
		toObject() {
			const data: {
				id?: string;
				label?: string;
				license_plate?: string;
			} = {};
			if (this.id != null) {
				data.id = this.id;
			}
			if (this.label != null) {
				data.label = this.label;
			}
			if (this.license_plate != null) {
				data.license_plate = this.license_plate;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_id && this.id.length) writer.writeString(1, this.id);
			if (this.has_label && this.label.length) writer.writeString(2, this.label);
			if (this.has_license_plate && this.license_plate.length)
				writer.writeString(3, this.license_plate);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VehicleDescriptor {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new VehicleDescriptor();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.id = reader.readString();
						break;
					case 2:
						message.label = reader.readString();
						break;
					case 3:
						message.license_plate = reader.readString();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): VehicleDescriptor {
			return VehicleDescriptor.deserialize(bytes);
		}
	}
	export class EntitySelector extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						agency_id?: string;
						route_id?: string;
						route_type?: number;
						trip?: TripDescriptor;
						stop_id?: string;
				  }
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == 'object') {
				if ('agency_id' in data && data.agency_id != undefined) {
					this.agency_id = data.agency_id;
				}
				if ('route_id' in data && data.route_id != undefined) {
					this.route_id = data.route_id;
				}
				if ('route_type' in data && data.route_type != undefined) {
					this.route_type = data.route_type;
				}
				if ('trip' in data && data.trip != undefined) {
					this.trip = data.trip;
				}
				if ('stop_id' in data && data.stop_id != undefined) {
					this.stop_id = data.stop_id;
				}
			}
		}
		get agency_id() {
			return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
		}
		set agency_id(value: string) {
			pb_1.Message.setField(this, 1, value);
		}
		get has_agency_id() {
			return pb_1.Message.getField(this, 1) != null;
		}
		get route_id() {
			return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
		}
		set route_id(value: string) {
			pb_1.Message.setField(this, 2, value);
		}
		get has_route_id() {
			return pb_1.Message.getField(this, 2) != null;
		}
		get route_type() {
			return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
		}
		set route_type(value: number) {
			pb_1.Message.setField(this, 3, value);
		}
		get has_route_type() {
			return pb_1.Message.getField(this, 3) != null;
		}
		get trip() {
			return pb_1.Message.getWrapperField(this, TripDescriptor, 4) as TripDescriptor;
		}
		set trip(value: TripDescriptor) {
			pb_1.Message.setWrapperField(this, 4, value);
		}
		get has_trip() {
			return pb_1.Message.getField(this, 4) != null;
		}
		get stop_id() {
			return pb_1.Message.getFieldWithDefault(this, 5, '') as string;
		}
		set stop_id(value: string) {
			pb_1.Message.setField(this, 5, value);
		}
		get has_stop_id() {
			return pb_1.Message.getField(this, 5) != null;
		}
		static fromObject(data: {
			agency_id?: string;
			route_id?: string;
			route_type?: number;
			trip?: ReturnType<typeof TripDescriptor.prototype.toObject>;
			stop_id?: string;
		}): EntitySelector {
			const message = new EntitySelector({});
			if (data.agency_id != null) {
				message.agency_id = data.agency_id;
			}
			if (data.route_id != null) {
				message.route_id = data.route_id;
			}
			if (data.route_type != null) {
				message.route_type = data.route_type;
			}
			if (data.trip != null) {
				message.trip = TripDescriptor.fromObject(data.trip);
			}
			if (data.stop_id != null) {
				message.stop_id = data.stop_id;
			}
			return message;
		}
		toObject() {
			const data: {
				agency_id?: string;
				route_id?: string;
				route_type?: number;
				trip?: ReturnType<typeof TripDescriptor.prototype.toObject>;
				stop_id?: string;
			} = {};
			if (this.agency_id != null) {
				data.agency_id = this.agency_id;
			}
			if (this.route_id != null) {
				data.route_id = this.route_id;
			}
			if (this.route_type != null) {
				data.route_type = this.route_type;
			}
			if (this.trip != null) {
				data.trip = this.trip.toObject();
			}
			if (this.stop_id != null) {
				data.stop_id = this.stop_id;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.has_agency_id && this.agency_id.length) writer.writeString(1, this.agency_id);
			if (this.has_route_id && this.route_id.length) writer.writeString(2, this.route_id);
			if (this.has_route_type) writer.writeInt32(3, this.route_type);
			if (this.has_trip) writer.writeMessage(4, this.trip, () => this.trip.serialize(writer));
			if (this.has_stop_id && this.stop_id.length) writer.writeString(5, this.stop_id);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EntitySelector {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new EntitySelector();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.agency_id = reader.readString();
						break;
					case 2:
						message.route_id = reader.readString();
						break;
					case 3:
						message.route_type = reader.readInt32();
						break;
					case 4:
						reader.readMessage(
							message.trip,
							() => (message.trip = TripDescriptor.deserialize(reader))
						);
						break;
					case 5:
						message.stop_id = reader.readString();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): EntitySelector {
			return EntitySelector.deserialize(bytes);
		}
	}
	export class TranslatedString extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						translation: TranslatedString.Translation[];
				  }
		) {
			super();
			pb_1.Message.initialize(
				this,
				Array.isArray(data) ? data : [],
				0,
				-1,
				[1],
				this.#one_of_decls
			);
			if (!Array.isArray(data) && typeof data == 'object') {
				this.translation = data.translation;
			}
		}
		get translation() {
			return pb_1.Message.getRepeatedWrapperField(
				this,
				TranslatedString.Translation,
				1
			) as TranslatedString.Translation[];
		}
		set translation(value: TranslatedString.Translation[]) {
			pb_1.Message.setRepeatedWrapperField(this, 1, value);
		}
		static fromObject(data: {
			translation?: ReturnType<typeof TranslatedString.Translation.prototype.toObject>[];
		}): TranslatedString {
			const message = new TranslatedString({
				translation: data.translation.map((item) => TranslatedString.Translation.fromObject(item))
			});
			return message;
		}
		toObject() {
			const data: {
				translation?: ReturnType<typeof TranslatedString.Translation.prototype.toObject>[];
			} = {};
			if (this.translation != null) {
				data.translation = this.translation.map((item: TranslatedString.Translation) =>
					item.toObject()
				);
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.translation.length)
				writer.writeRepeatedMessage(1, this.translation, (item: TranslatedString.Translation) =>
					item.serialize(writer)
				);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TranslatedString {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new TranslatedString();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						reader.readMessage(message.translation, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								1,
								TranslatedString.Translation.deserialize(reader),
								TranslatedString.Translation
							)
						);
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): TranslatedString {
			return TranslatedString.deserialize(bytes);
		}
	}
	export namespace TranslatedString {
		export class Translation extends pb_1.Message {
			#one_of_decls: number[][] = [];
			constructor(
				data?:
					| any[]
					| {
							text: string;
							language?: string;
					  }
			) {
				super();
				pb_1.Message.initialize(
					this,
					Array.isArray(data) ? data : [],
					0,
					-1,
					[],
					this.#one_of_decls
				);
				if (!Array.isArray(data) && typeof data == 'object') {
					this.text = data.text;
					if ('language' in data && data.language != undefined) {
						this.language = data.language;
					}
				}
			}
			get text() {
				return pb_1.Message.getField(this, 1) as string;
			}
			set text(value: string) {
				pb_1.Message.setField(this, 1, value);
			}
			get has_text() {
				return pb_1.Message.getField(this, 1) != null;
			}
			get language() {
				return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
			}
			set language(value: string) {
				pb_1.Message.setField(this, 2, value);
			}
			get has_language() {
				return pb_1.Message.getField(this, 2) != null;
			}
			static fromObject(data: { text?: string; language?: string }): Translation {
				const message = new Translation({
					text: data.text
				});
				if (data.language != null) {
					message.language = data.language;
				}
				return message;
			}
			toObject() {
				const data: {
					text?: string;
					language?: string;
				} = {};
				if (this.text != null) {
					data.text = this.text;
				}
				if (this.language != null) {
					data.language = this.language;
				}
				return data;
			}
			serialize(): Uint8Array;
			serialize(w: pb_1.BinaryWriter): void;
			serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
				const writer = w || new pb_1.BinaryWriter();
				if (this.has_text && this.text.length) writer.writeString(1, this.text);
				if (this.has_language && this.language.length) writer.writeString(2, this.language);
				if (!w) return writer.getResultBuffer();
			}
			static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Translation {
				const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
					message = new Translation();
				while (reader.nextField()) {
					if (reader.isEndGroup()) break;
					switch (reader.getFieldNumber()) {
						case 1:
							message.text = reader.readString();
							break;
						case 2:
							message.language = reader.readString();
							break;
						default:
							reader.skipField();
					}
				}
				return message;
			}
			serializeBinary(): Uint8Array {
				return this.serialize();
			}
			static deserializeBinary(bytes: Uint8Array): Translation {
				return Translation.deserialize(bytes);
			}
		}
	}
}
